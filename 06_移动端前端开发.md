项目名 e5share-web-mobile
使用 TypeScript
使用 Vant4 https://vant-contrib.gitee.io/vant/#/zh-CN
https://vant-ui.github.io/vant/#/zh-CN

项目地址 https://github.com/haruki1953/e5share-web-mobile.git

参考：
	[04_前端开发记录](04_前端开发记录.md)
	[day08-day10-智慧商城项目](../240207vueNote/day08-day10-智慧商城项目.md)


# 一、初始化项目
## 1.1 pnpm 创建项目
创建项目：pnpm create vue  
![](assets/Pasted%20image%2020240430134542.png)
- 安装依赖：pnpm install
- 运行项目：pnpm dev

## 1.2 ESLint & prettier 配置代码风格
[【04_前端开发记录】1.2 ESLint & prettier 配置代码风格](04_前端开发记录.md#1.2%20ESLint%20&%20prettier%20配置代码风格)

ts可能有区别，但大致是一样的

## 1.3 基于 husky 的代码检查工作流
[【04_前端开发记录】1.3 基于 husky 的代码检查工作流](04_前端开发记录.md#1.3%20基于%20husky%20的代码检查工作流)

## 1.4 调整项目目录
[【04_前端开发记录】1.4 调整项目目录](04_前端开发记录.md#1.4%20调整项目目录)

注意
```vue
<script setup lang="ts"></script>
```


## 1.5 引入 Vant4 组件库
https://vant-contrib.gitee.io/vant/#/zh-CN/quickstart

安装 pnpm add vant@4.8.11

### 自动按需引入组件
#### 1. 安装插件
```
pnpm add @vant/auto-import-resolver unplugin-vue-components unplugin-auto-import -D
```

#### 2. 配置插件
在 `vite.config.js/ts` 文件中配置插件：
```ts
import vue from '@vitejs/plugin-vue';
import AutoImport from 'unplugin-auto-import/vite';
import Components from 'unplugin-vue-components/vite';
import { VantResolver } from '@vant/auto-import-resolver';

export default {
  plugins: [
    vue(),
    AutoImport({
      resolvers: [VantResolver()],
    }),
    Components({
      resolvers: [VantResolver()],
    }),
  ],
};
```

### 解决自动引入造成的变量类型未声明问题
以轻提示 showToast 为例，虽然已经自动引入，但在使用是会显示变量未定义。

#### 在 eslintrc.cjs 中声明全局变量名
```js
// eslintrc.cjs
module.exports = {
  ...
  globals: {
    showToast: 'readonly',
    showLoadingToast: 'readonly',
    showSuccessToast: 'readonly',
    showFailToast: 'readonly'
  }
}
```
对于js项目，这样就足够了。但是对于ts还不行，因为编译器无法得知类型

#### 在 tsconfig.app.json 中添加自动引入生成的类型声明文件
项目根目录下的 auto-imports.d.ts 与 components.d.ts 都是自动引入插件所生成的，其中包含了所使用的组件的类型信息。
需要手动将这两个类型声明文件，添加至 tsconfig.app.json 中的 include 数组内
```json
{
  // ...
  "include": [
    // ...
    "auto-imports.d.ts",
    "components.d.ts"
  ],
}
```
此时再使用 showToast() 就可以看见类型了，也不报错了
> 这个好像要在网页预览之后，插件才会自动生成对应的类型导入

## 1.6 项目中的 vw 适配
[postcss-px-to-viewport](https://github.com/evrone/postcss-px-to-viewport) 是一款 PostCSS 插件，用于将 px 单位转化为 vw/vh 单位。
官方说明： https://vant-ui.github.io/vant/#/zh-CN/advanced-usage#liu-lan-qi-gua-pei

安装插件：pnpm add postcss-px-to-viewport@1.1.1 -D
项目根目录， 新建postcss的配置文件`postcss.config.js`
```js
// postcss.config.js
module.exports = {
  plugins: {
    'postcss-px-to-viewport': {
      // vw适配的标准屏的宽度 iphoneX
      // 设计图 750，调成1倍 => 适配375标准屏幕
      // 设计图 640，调成1倍 => 适配320标准屏幕
      viewportWidth: 375,
    },
  },
};
```
> 在ts项目中使用时可能会有问题，需要重命名为 postcss.config.cjs，module.exports 如果报错可添加 `/* eslint-disable no-undef */`

此时设置某元素 `width: 200px;`，就会以375px为基准，按比例设置宽度

## 1.7 Pinia
[【04_前端开发记录】1.7 Pinia](04_前端开发记录.md#1.7%20Pinia)
注意新建文件时是ts
顺便创建好AuthStore

## 1.8 数据交互 - 请求工具设计
[【04_前端开发记录】1.8 数据交互 - 请求工具设计](04_前端开发记录.md#1.8%20数据交互%20-%20请求工具设计)

因为使用ts，做了一些小修改
使用vant的 showFailToast('失败文案'); 来提示错误
```ts
import axios from 'axios'
import { useAuthStore } from '@/stores'
import router from '@/router'

const baseURL = 'http://big-event-vue-api-t.itheima.net'

const instance = axios.create({
  // TODO 1. 基础地址，超时时间
  baseURL,
  timeout: 10000
})

// 请求拦截器
instance.interceptors.request.use(
  (config) => {
    // TODO 2. 携带token
    const useStore = useAuthStore()
    if (useStore.token) {
      config.headers.Authorization = useStore.token
    }
    return config
  },
  (err) => Promise.reject(err)
)

// 响应拦截器
instance.interceptors.response.use(
  (res) => {
    // TODO 4. 摘取核心响应数据
    if (res.data.code === 0) {
      return res
    }
    if (res.status === 204) {
      // 204 响应表示请求成功但无内容，不需要给出错误提示
      return res
    }
    // TODO 3. 处理业务失败
    // 处理业务失败, 给错误提示，抛出错误
    showFailToast(res.data.message || '服务异常')
    return Promise.reject(res.data)
  },
  (err) => {
    // TODO 5. 处理401错误
    // 错误的特殊情况 => 401 权限不足 或 token 过期 => 拦截到登录
    if (err.response?.status === 401) {
      router.push('/login')
    }

    // 错误的默认情况 => 只要给提示
    showFailToast(err.response?.data.message || '服务异常')
    return Promise.reject(err)
  }
)

export default instance
```

顺便导入配置文件，注意要改为ts

## 1.9 整体路由设计

|path|文件|功能|路由级别|
|---|---|---|---|
|/login|views/login/LoginPage.vue|登录&注册|一级路由|
|/setting|views/setting/SettingPage.vue|设置页|一级路由|
|/user/:id|views/user/UserPage.vue|用户主页|一级路由|
|/post-info|views/post/PostInfo.vue|动态详情|一级路由|
|/|views/layout/LayoutContainer.vue|布局架子|一级路由|
|/home|views/home/HomePage.vue|主页|二级路由|
|/user-list|views/user/UserList.vue|用户列表|二级路由|
|/share|views/share/ShareInfo.vue|e5分享管理页|二级路由|
|/notif|views/notif/NotifPage.vue|通知页|二级路由|
|/post|views/post/PostPage.vue|动态页|二级路由|

## 1.10 导入现成的数据逻辑等代码
导入已经写好的api、store、utils等代码

### 使用ts重写封装的api方法，为封装的api方法标注类型
暂时还是觉得就在写方法的同时标注类型比较方便，怎么方便怎么来吧。
如果需要复用，就写在@/types/api.d.ts。如果数据类型在项目中也要使用，就在types文件夹新建文件来写

对于响应数据，方法返回值类型为 `Promise<AxiosResponse<any, any>>`，两个any分别是成功与失败的响应数据，一般只指定第一个就可以了
```ts
/* 在api.d.ts对其做封装 */
import type { AxiosResponse } from 'axios'
// api方法返回值类型的，dataType为返回数据的类型
export type ResData<DataType = undefined> = Promise<
  AxiosResponse<{
    code: number
    message: string
    data: DataType
  }>
>
// 对于登录接口，没有data属性，而是token
export type ResToken = Promise<
  AxiosResponse<{
    code: number
    message: string
    token: string
  }>
>

/* 使用示例 */
// api/auth.ts
import request from '@/utils/request'
import type { ResData, ResToken } from '@/types/api'

export const authRegisterService = (data: {
  username: string
  password: string
  email: string
}): ResData => request.post('/auth/register', data)

export const authLoginByUsernameService = (data: {
  username: string
  password: string
}): ResToken => request.post('/auth/login/username', data)

// api/public.ts
import request from '@/utils/request'
import type { ResData } from '@/types/api'
import type { UserRes } from '@/types/user'

export const publicGetUsersService = (): ResData<UserRes[]> =>
  request.get('/public/users')
```


### 使用ts重写utils中的模块

### 使用ts重写store中的模块


# 二、登录注册页面
对于vant4中的组件，应该导入 `组件名Instance`，否则会没有方法的类型，下面以Form表单组件为例
```ts
import type TestBox from '@/components/TestBox.vue'
import type { FormInstance } from 'vant'

// 自己封装的组件
const refTestBox = ref<InstanceType<typeof TestBox>>()
// vant4表单组件
const form = ref<FormInstance>()
```

:deep()控制组件中的样式
```scss
.van-cell {
  :deep() {
    .van-cell__value {
      display: flex;
      justify-content: space-between;
    }
  }
}
```

定义校验规则时要声明类型 `FieldRule[]` 
```ts
// 用户相关信息的验证规则
export const userRules: Record<
  'username' | 'email' | 'password' | 'nickname' | 'contactInfo' | 'bio',
  FieldRule[]
> = {
  username: [
    { required: true, message: '请输入用户名', trigger: 'onBlur' },
    {
      pattern: /^[a-zA-Z0-9_]{1,32}$/,
      message: '用户名必须是 1-32位 的字符，只能包含字母数字下划线',
      trigger: 'onBlur'
    }
  ],
  // ...
}

const rules: Record<'repassword', FieldRule[]> & typeof userRules = {
  ...userRules,
  repassword: [
    {
      validator: (value: string) => value === formModel.value.password,
      message: '两次输入密码不一致',
      trigger: 'onBlur'
    }
  ]
}
```


# 三、layout页面布局
完成路由访问拦截

Tabbar 标签栏： https://vant-ui.github.io/vant/#/zh-CN/tabbar

在app.vue请求数据时，导入dataManage模块会报错，好像是因为在初始化pinia之前进行了userSrore。在onMounted中异步导入解决
```ts
onMounted(async () => {
  const { loadAllData } = await import('./utils/dataManage')
  loadAllData()
})
```