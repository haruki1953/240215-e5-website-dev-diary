项目名 e5share-web-mobile
使用 TypeScript
使用 Vant4 https://vant-contrib.gitee.io/vant/#/zh-CN
https://vant-ui.github.io/vant/#/zh-CN

项目地址 https://github.com/haruki1953/e5share-web-mobile.git

参考：
	[04_前端开发记录](04_前端开发记录.md)
	[day08-day10-智慧商城项目](../240207vueNote/day08-day10-智慧商城项目.md)


# 一、初始化项目
## 1.1 pnpm 创建项目
创建项目：pnpm create vue  
![](assets/Pasted%20image%2020240430134542.png)
- 安装依赖：pnpm install
- 运行项目：pnpm dev

## 1.2 ESLint & prettier 配置代码风格
[【04_前端开发记录】1.2 ESLint & prettier 配置代码风格](04_前端开发记录.md#1.2%20ESLint%20&%20prettier%20配置代码风格)

ts可能有区别，但大致是一样的

## 1.3 基于 husky 的代码检查工作流
[【04_前端开发记录】1.3 基于 husky 的代码检查工作流](04_前端开发记录.md#1.3%20基于%20husky%20的代码检查工作流)

## 1.4 调整项目目录
[【04_前端开发记录】1.4 调整项目目录](04_前端开发记录.md#1.4%20调整项目目录)

注意
```vue
<script setup lang="ts"></script>
```


## 1.5 引入 Vant4 组件库
https://vant-contrib.gitee.io/vant/#/zh-CN/quickstart

安装 pnpm add vant@4.8.11

### 自动按需引入组件
#### 1. 安装插件
```
pnpm add @vant/auto-import-resolver unplugin-vue-components unplugin-auto-import -D
```

#### 2. 配置插件
在 `vite.config.js/ts` 文件中配置插件：
```ts
import vue from '@vitejs/plugin-vue';
import AutoImport from 'unplugin-auto-import/vite';
import Components from 'unplugin-vue-components/vite';
import { VantResolver } from '@vant/auto-import-resolver';

export default {
  plugins: [
    vue(),
    AutoImport({
      resolvers: [VantResolver()],
    }),
    Components({
      resolvers: [VantResolver()],
    }),
  ],
};
```

### 解决自动引入造成的变量类型未声明问题
以轻提示 showToast 为例，虽然已经自动引入，但在使用是会显示变量未定义。

#### 在 eslintrc.cjs 中声明全局变量名
```js
// eslintrc.cjs
module.exports = {
  ...
  globals: {
    showToast: 'readonly',
    showLoadingToast: 'readonly',
    showSuccessToast: 'readonly',
    showFailToast: 'readonly'
  }
}
```
对于js项目，这样就足够了。但是对于ts还不行，因为编译器无法得知类型

#### 在 tsconfig.app.json 中添加自动引入生成的类型声明文件
项目根目录下的 auto-imports.d.ts 与 components.d.ts 都是自动引入插件所生成的，其中包含了所使用的组件的类型信息。
需要手动将这两个类型声明文件，添加至 tsconfig.app.json 中的 include 数组内
```json
{
  // ...
  "include": [
    // ...
    "auto-imports.d.ts",
    "components.d.ts"
  ],
}
```
此时再使用 showToast() 就可以看见类型了，也不报错了
> 这个好像要在网页预览之后，插件才会自动生成对应的类型导入

## 1.6 项目中的 vw 适配
[postcss-px-to-viewport](https://github.com/evrone/postcss-px-to-viewport) 是一款 PostCSS 插件，用于将 px 单位转化为 vw/vh 单位。
官方说明： https://vant-ui.github.io/vant/#/zh-CN/advanced-usage#liu-lan-qi-gua-pei

安装插件：pnpm add postcss-px-to-viewport@1.1.1 -D
项目根目录， 新建postcss的配置文件`postcss.config.js`
```js
// postcss.config.js
module.exports = {
  plugins: {
    'postcss-px-to-viewport': {
      // vw适配的标准屏的宽度 iphoneX
      // 设计图 750，调成1倍 => 适配375标准屏幕
      // 设计图 640，调成1倍 => 适配320标准屏幕
      viewportWidth: 375,
    },
  },
};
```
> 在ts项目中使用时可能会有问题，需要重命名为 postcss.config.cjs，module.exports 如果报错可添加 `/* eslint-disable no-undef */`

此时设置某元素 `width: 200px;`，就会以375px为基准，按比例设置宽度

## 1.7 Pinia
[【04_前端开发记录】1.7 Pinia](04_前端开发记录.md#1.7%20Pinia)
注意新建文件时是ts
顺便创建好AuthStore

## 1.8 数据交互 - 请求工具设计
[【04_前端开发记录】1.8 数据交互 - 请求工具设计](04_前端开发记录.md#1.8%20数据交互%20-%20请求工具设计)

因为使用ts，做了一些小修改
使用vant的 showFailToast('失败文案'); 来提示错误
```ts
import axios from 'axios'
import { useAuthStore } from '@/stores'
import router from '@/router'

const baseURL = 'http://big-event-vue-api-t.itheima.net'

const instance = axios.create({
  // TODO 1. 基础地址，超时时间
  baseURL,
  timeout: 10000
})

// 请求拦截器
instance.interceptors.request.use(
  (config) => {
    // TODO 2. 携带token
    const useStore = useAuthStore()
    if (useStore.token) {
      config.headers.Authorization = useStore.token
    }
    return config
  },
  (err) => Promise.reject(err)
)

// 响应拦截器
instance.interceptors.response.use(
  (res) => {
    // TODO 4. 摘取核心响应数据
    if (res.data.code === 0) {
      return res
    }
    if (res.status === 204) {
      // 204 响应表示请求成功但无内容，不需要给出错误提示
      return res
    }
    // TODO 3. 处理业务失败
    // 处理业务失败, 给错误提示，抛出错误
    showFailToast(res.data.message || '服务异常')
    return Promise.reject(res.data)
  },
  (err) => {
    // TODO 5. 处理401错误
    // 错误的特殊情况 => 401 权限不足 或 token 过期 => 拦截到登录
    if (err.response?.status === 401) {
      router.push('/login')
    }

    // 错误的默认情况 => 只要给提示
    showFailToast(err.response?.data.message || '服务异常')
    return Promise.reject(err)
  }
)

export default instance
```

顺便导入配置文件，注意要改为ts

## 1.9 整体路由设计

|path|文件|功能|路由级别|
|---|---|---|---|
|/login|views/login/LoginPage.vue|登录&注册|一级路由|
|/setting|views/setting/SettingPage.vue|设置页|一级路由|
|/user/:id|views/user/UserPage.vue|用户主页|一级路由|
|/post-info|views/post/PostInfo.vue|动态详情|一级路由|
|/|views/layout/LayoutContainer.vue|布局架子|一级路由|
|/home|views/home/HomePage.vue|主页|二级路由|
|/user-list|views/user/UserList.vue|用户列表|二级路由|
|/share|views/share/ShareInfo.vue|e5分享管理页|二级路由|
|/notif|views/notif/NotifPage.vue|通知页|二级路由|
|/post|views/post/PostPage.vue|动态页|二级路由|

### 【240513】修改路由

|path|文件|功能|路由级别|
|---|---|---|---|
|/login|views/login/LoginPage.vue|登录&注册|一级路由|
|/|views/layout/BasePage.vue|基础页面|一级路由|
|/setting|views/setting/SettingPage.vue|设置页|二级路由|
|/user/:id|views/user/UserPage.vue|用户主页|二级路由|
|/post-info|views/post/PostInfo.vue|动态详情|二级路由|
|/layout|views/layout/LayoutContainer.vue|主页布局架子|二级路由|
|/home|views/home/HomePage.vue|主页|三级路由|
|/user-list|views/user/UserList.vue|用户列表|三级路由|
|/share|views/share/ShareInfo.vue|e5分享管理页|三级路由|
|/notif|views/notif/NotifPage.vue|通知页|三级路由|
|/post|views/post/PostPage.vue|动态页|三级路由|

## 1.10 导入现成的数据逻辑等代码
导入已经写好的api、store、utils等代码

### 使用ts重写封装的api方法，为封装的api方法标注类型
暂时还是觉得就在写方法的同时标注类型比较方便，怎么方便怎么来吧。
如果需要复用，就写在@/types/api.d.ts。如果数据类型在项目中也要使用，就在types文件夹新建文件来写

对于响应数据，方法返回值类型为 `Promise<AxiosResponse<any, any>>`，两个any分别是成功与失败的响应数据，一般只指定第一个就可以了
```ts
/* 在api.d.ts对其做封装 */
import type { AxiosResponse } from 'axios'
// api方法返回值类型的，dataType为返回数据的类型
export type ResData<DataType = undefined> = Promise<
  AxiosResponse<{
    code: number
    message: string
    data: DataType
  }>
>
// 对于登录接口，没有data属性，而是token
export type ResToken = Promise<
  AxiosResponse<{
    code: number
    message: string
    token: string
  }>
>

/* 使用示例 */
// api/auth.ts
import request from '@/utils/request'
import type { ResData, ResToken } from '@/types/api'

export const authRegisterService = (data: {
  username: string
  password: string
  email: string
}): ResData => request.post('/auth/register', data)

export const authLoginByUsernameService = (data: {
  username: string
  password: string
}): ResToken => request.post('/auth/login/username', data)

// api/public.ts
import request from '@/utils/request'
import type { ResData } from '@/types/api'
import type { UserRes } from '@/types/user'

export const publicGetUsersService = (): ResData<UserRes[]> =>
  request.get('/public/users')
```


### 使用ts重写utils中的模块

### 使用ts重写store中的模块


# 二、登录注册页面
对于vant4中的组件，应该导入 `组件名Instance`，否则会没有方法的类型，下面以Form表单组件为例
```ts
import type TestBox from '@/components/TestBox.vue'
import type { FormInstance } from 'vant'

// 自己封装的组件
const refTestBox = ref<InstanceType<typeof TestBox>>()
// vant4表单组件
const form = ref<FormInstance>()
```

:deep()控制组件中的样式
```scss
.van-cell {
  :deep() {
    .van-cell__value {
      display: flex;
      justify-content: space-between;
    }
  }
}
```

定义校验规则时要声明类型 `FieldRule[]` 
```ts
// 用户相关信息的验证规则
export const userRules: Record<
  'username' | 'email' | 'password' | 'nickname' | 'contactInfo' | 'bio',
  FieldRule[]
> = {
  username: [
    { required: true, message: '请输入用户名', trigger: 'onBlur' },
    {
      pattern: /^[a-zA-Z0-9_]{1,32}$/,
      message: '用户名必须是 1-32位 的字符，只能包含字母数字下划线',
      trigger: 'onBlur'
    }
  ],
  // ...
}

const rules: Record<'repassword', FieldRule[]> & typeof userRules = {
  ...userRules,
  repassword: [
    {
      validator: (value: string) => value === formModel.value.password,
      message: '两次输入密码不一致',
      trigger: 'onBlur'
    }
  ]
}
```


# 三、layout页面布局
完成路由访问拦截

Tabbar 标签栏： https://vant-ui.github.io/vant/#/zh-CN/tabbar

在app.vue请求数据时，导入dataManage模块会报错，好像是因为在初始化pinia之前进行了userSrore。在onMounted中异步导入解决
```ts
onMounted(async () => {
  const { loadAllData } = await import('./utils/dataManage')
  loadAllData()
})
```

对于在元素属性中设置大小的组件，尽量放在css中实现，这样vw才能生效

vant4没有v-loading指令，自己实现了类似的效果

在弹出层中的底部添加联系方式与友情链接折叠面板

# 四、主页
## 用户卡片
基于类型声明props，默认值
```ts
const props = withDefaults(
  defineProps<{
    userId: number
    usernameLink?: boolean
  }>(),
  {
    usernameLink: true
  }
)
```
完成了主页
头像懒加载

# 五、用户列表，用户主页
悬浮球、搜索框

用户主页感觉和用户卡片差不多，修改一下

**用户主页中的服务：**
- ApplySheet 申请分享面板 
- StopSheet 停止接受分享面板 
- AddShareSheet 添加分享信息面板
- 关注/查看动态

## 切换路由时，滚动条回到顶部
[【散装笔记】切换路由时，滚动条回到顶部](笔记/散装笔记.md#切换路由时，滚动条回到顶部)

# 六、e5分享管理页
- ShareRegisterSheet 分享登记面板
	- E5dateForm 日期选择表单
- ShareCancelSheet 分享注销面板
- ShareInfoUpdateSheet 分享信息修改面板

完善了e5进度条

## 用户显示组件，文字超出省略
[【散装笔记】文字超出省略](笔记/散装笔记.md#文字超出省略)

## 为组件的 emits 标注类型
```ts
const emit = defineEmits<{
  (e: 'update:modelValue', value: E5Date): void
}>()
```

## 日期选择表单
在设置通过总天数与剩余天数设置日期时需要取最近的日期，因为在总天数与剩余天数get时是四舍五入的，不保持一致的话在拖动滑条时会有问题
[04_前端开发记录](04_前端开发记录.md) 也要改进这个

# 七、通知页
## NotifCard 通知卡片
完成

## 通知已读功能
放弃单独为某个通知标记已读。在通知页关闭时全部已读

## 重点通知处理
- 在profileStore封装 检查重点通知 方法，在app.vue 加载所有数据loadAllData之后调用
- 重点通知保存在profileStore中，不进行持久化
- 通知图标小红点

## 解决了 app.vue里onMounted不生效？问题
问题：app.vue里的onMounted不生效？onMounted好像还并未挂载route之类的
解决：新建页面 BasePage.vue，修改路由，以BasePage为一级路由，其余需要数据的页面为其二级路由、三级路由（登录页不需要数据所以为一级路由）。此时在BasePage中初始化数据
[【240513】修改路由](#【240513】修改路由)
这下彻底解决了，stores之类的也不需要异步引入了

其实 检查重点通知 放在 profileStore.getProfile 中也可以，那就放getProfile最后吧

## 分享确认面板、添加面板
放弃以事件的方式从 通知卡片 传递到 通知页面，直接在通知卡片内加入弹出面板组件，通过v-if条件控制，应该不会导致性能问题

- AddShareSheet 添加面板 现成的
- ShareConfirmSheet 分享确认面板

# 八、动态
## 动态菜单页
### 动态菜单
动态未读数
点击跳转'/post-info/:id'

### 悬浮球、弹出面板
说明、全部已读功能

## 动态详情页
导航栏，右侧头像，点击跳转用户主页
悬浮球 唤出面板

关闭页面时清除已读
> onBeforeUnmount时路由好像已经改变了，所以不能再用计算属性来获取路由路径里的id。要在onMounted时保存路由路径中的id

用户主页里的查看动态改一下，要跳转到 post-info/:id

### PostCard 动态卡片
动态显示、删除动态

### SendSheet 动态发送面板
发送动态、清空动态、取消关注


# 九、设置
- ProfileCard
- AvatarCard
- EmailCard
- PasswordCard
- E5Card
- ClearNotifCard
- DeleteUserCard

E5dateForm 又有一点问题，pc端也有问题
【问题解决】在获取new Date()时dateRound一下（日期四舍五入），由于出现了显示不一致的问题，在E5sharingProgress也要日期四舍五入

