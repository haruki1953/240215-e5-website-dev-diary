## 异步函数必须要catch
在 Node.js 中，如果一个未捕获的错误（uncaught error）在顶层代码（即没有被任何 `try...catch` 或者 Promise 的 `.catch()` 方法捕获）发生，它会导致 Node.js 进程崩溃。这种情况下，Node.js 会打印错误信息并终止进程。

```javascript
async function asyncFunction() {
	throw new Error('This is an uncaught error');
}

try { 
	asyncFunction(); 
} catch (error) { 
	console.error('Caught an error:', error); 
}
```

在这个例子中，尽管 `asyncFunction()` 可能会抛出一个错误，但由于 `asyncFunction()` 是一个异步函数，它会立即返回一个 Promise，而不会等待异步操作完成。因此，在 `try...catch` 块中捕获错误的尝试会失败，因为在执行 `try` 块时，`asyncFunction()` 还没有执行完成，因此错误不会被捕获。

## 使用`escape`转义特殊字符（也可以不用）
（Vue 的 `{{}}` 插值表达式和 `v-bind` 指令都会自动转义特殊字符）  
对用户可以自定义的信息，转义特殊字符  
安装： pnpm add lodash
```js
import { escape } from 'lodash';

let result = escape('<html>');
console.log(result);  // 输出：<html>
```

## 客户端缓存与304状态码
日志中发现，在有些get请求时"statusCode":304，原来是因为客户端缓存。真是太好了，原来在不知道的底层已经有这么好的优化了

状态码 `304` 通常是与客户端缓存相关的。当客户端发起请求时，如果它已经具有了这个资源的副本，并且带有了相应的缓存验证头（比如 `If-Modified-Since` 或 `If-None-Match`），服务器会根据这些验证头判断资源是否有更新。如果资源没有更新，服务器就会返回 `304 Not Modified` 状态码，告诉客户端可以继续使用它已经有的资源副本，而无需重新下载。

因此，当你在前端没有特殊操作时，很可能是因为客户端已经有了这个资源的缓存副本，并且在请求中发送了相应的验证头，导致服务器返回了 `304` 状态码。这是一种常见的优化机制，可以减少网络流量，加快页面加载速度。

## 切换路由时，滚动条回到顶部
Vue3中，在路由配置中使用`scrollBehavior`方法来实现切换路由后滚动条回到顶部的功能。
```javascript
import { createRouter, createWebHistory } from 'vue-router'

const router = createRouter({
  history: createWebHistory(),
  routes: [
    // ...你的路由配置
  ],
  scrollBehavior (to, from, savedPosition) {
    return { top: 0 }
  }
})

export default router
```

在这个例子中，`scrollBehavior`方法返回一个滚动位置的对象，`{ top: 0 }`表示滚动到页面的顶部。当你切换路由时，这个方法就会被调用，从而实现滚动条回到顶部的效果。希望这个信息对你有所帮助！

## 文字超出省略
```html
<div class="name-box">
  <div class="my-text-h3">{{ user.nickname }}</div>
  <div
    @click.stop="usernameLink && $router.push(`/user/${user.id}`)"
    class="my-text-p2 van-haptics-feedback"
  >
    @{{ user.username }}
  </div>
</div>

.name-box {
  overflow: hidden;
  div {
    overflow: hidden;
    white-space: nowrap;
    text-overflow: ellipsis;
  }
}
```
注意：此时在flex的justify-content: space-between;布局下，好像就必须要指定宽度了